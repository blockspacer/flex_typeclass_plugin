[[~ // parameters begin

const size_t ReflectedStructInfoMethodsSize =
    ReflectedStructInfo->methods.size();

const size_t ReflectedStructInfoCompoundIdSize =
    ReflectedStructInfo->compoundId.size();

// parameters end
/* no newline */ ~]][[~]]
// This is generated file. Do not modify directly.
// Path to the code generator: [[+ generator_path +]].

[[+ startHeaderGuard(headerGuard) /* no newline */ +]][[~]]

[[~]] for(const auto& fileName: generator_includes) {
[[+ fileName +]]
[[~]] } // end for

#include <array>
#include <functional>
#include <memory>

namespace poly {
namespace generated {

[[~]] /**
[[~]] Getting rid of member functions.
[[~]] Decouples objects from their implementation.
[[~]] EXAMPLE:
[[~]]   template<
[[~]]     typename T0,
[[~]]     typename V,
[[~]]     typename std::enable_if<std::is_same<MagicItem, T0>::value>::type* = nullptr
[[~]]   >
[[~]]   void has_enough_mana(const V&, const char *spellname) noexcept ;
[[~]]
[[~]] USAGE EXAMPLE:
[[~]]   template<>
[[~]]   void has_enough_mana<DEFINE_MagicItem, FireSpell>
[[~]]       (const FireSpell& data, const char* spellname) noexcept {
[[~]]       std::cout << "(lib1) has_enough_mana " << " by "
[[~]]         << data.title << " " << spellname << std::endl;
[[~]]   }
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods) {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = isTypeclassMethod(method);
[[~]]      const std::string tplTypenames = expandTemplateTypes(method->params);
[[~]]      if(needPrint) {
  template<
    [[+ tplTypenames +]][[+ tplTypenames.empty() ? "" : "," +]]
    typename T,
    typename V,
[[~]]    // where fullCompoundId is combination of
[[~]]    // impl types (types may be templated)
[[~]]    const std::string fullCompoundId
[[~]]     = joinWithSeparator(
[[~]]         ReflectedStructInfo->compoundId
[[~]]         , ", "
[[~]]         , StrJoin::STRIP_LAST_SEPARATOR);
[[~]]    const std::string methodSpecificators
[[~]]       = printMethodForwarding(
[[~]]           method
[[~]]           , kSeparatorWhitespace
[[~]]           // what method printer is allowed to print
[[~]]           , MethodPrinter::Forwarding::Options::FORWARDING_ALL
[[~]]             & ~MethodPrinter::Forwarding::Options::VIRTUAL);
    typename std::enable_if<std::is_same<Typeclass<[[+ fullCompoundId +]]>, T>::value>::type* = nullptr
  >
[[+ methodSpecificators +]][[~]] /* no newline */
[[+ " " +]][[+ method->name +]][[~]] /* no newline */
[[~]]   // method has arguments
  (const V&[[~]]/* no newline */
[[~]] if(methodParamsSize) {
[[+   ", " +]][[~]] /* no newline */
[[+ expandMethodParameterDeclarations(method->params) +]][[~]] /* no newline */
[[~]] } // methodParamsSize
  ) [[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
;
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

// typeclass will store pointer to |implBase_|
// We use |implBase_| as base class for typeclass instance
[[~]] // where `fullBaseType` is trait like `Printable`
template<>
struct TypeclassImplBase<[[+ fullBaseType +]]> {
  TypeclassImplBase() = default;

  // We store a pointer to the base type
  // and rely on TypeclassImplBase's virtual dtor to free the object.
  virtual ~TypeclassImplBase() {}

  virtual
    std::unique_ptr<TypeclassImplBase>
      clone() const = 0;

  virtual
    std::unique_ptr<TypeclassImplBase>
      move_clone() = 0;

[[~]] /**
[[~]] Generate functions. Example:
[[~]]   virtual void __has_enough_mana(
[[~]]     const char *spellname) const noexcept = 0 ;
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods) {
[[~]]      const bool needPrint = isTypeclassMethod(method);
[[~]]      if(needPrint) {
[[~]]        const std::string methodSpecificators
[[~]]           = printMethodForwarding(
[[~]]               method
[[~]]               , kSeparatorWhitespace
[[~]]               // what method printer is allowed to print
[[~]]               , MethodPrinter::Forwarding::Options::FORWARDING_ALL);
[[~]]        if(method->isTemplate()) {
template< [[+ expandTemplateNames(method->tplParams) +]] >
[[~]]        } // method->isTemplate
[[+ methodSpecificators +]][[~]] /* no newline */
[[+ " __" +]][[+ method->name +]][[~]] /* no newline */
[[~]]   // method has arguments
  (
[[+ expandMethodParameterDeclarations(method->params) +]][[~]] /* no newline */
  ) [[~]] /* no newline */
[[~]]        const std::string methodTrailing
[[~]]           = printMethodTrailing(
[[~]]               method
[[~]]               , kSeparatorWhitespace
[[~]]               // what method printer is allowed to print
[[~]]               , MethodPrinter::Trailing::Options::TRAILING_NOTHING
[[~]]                 | MethodPrinter::Trailing::Options::CONST
[[~]]                 | MethodPrinter::Trailing::Options::NOEXCEPT
[[~]]                 | MethodPrinter::Trailing::Options::PURE
[[~]]                 | MethodPrinter::Trailing::Options::DELETED
[[~]]                 | MethodPrinter::Trailing::Options::DEFAULT
[[~]]                 | MethodPrinter::Trailing::Options::BODY);
[[+ methodTrailing +]][[~]] /* no newline */
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

};

[[~]] // where `fullBaseType` is trait like `Printable`
template<>
struct Typeclass<[[+ fullBaseType +]]> {
  Typeclass()
    : implBase_{}
  {}

  Typeclass(
    const Typeclass<[[+ fullBaseType +]]>& rhs)
    : implBase_(rhs.implBase_->clone())
  {}

  Typeclass(Typeclass<[[+ fullBaseType +]]>&& rhs)
  {
    implBase_ = rhs.implBase_->move_clone();
  }

[[~]] // where ImplType is impl that can behave as `fullBaseType`
  template<
    typename ImplType
    /// \note use TypeclassRef<ImplType> for references
    //, typename = IsNotReference<ImplType>
    /// \note can't pass Typeclass here
    , typename std::enable_if<
        !std::is_same<Typeclass, std::decay_t<ImplType>>::value
      >::type* = nullptr
  >
  Typeclass(ImplType&& impl)
    : implBase_(
        std::make_unique<
          TypeclassImpl<
            std::decay_t<ImplType>
            , [[+ fullBaseType +]]
          >
        >
        (std::forward<ImplType>(impl)))
  {}

  Typeclass<[[+ fullBaseType +]]>& operator=
    (const Typeclass<[[+ fullBaseType +]]>& rhs)
  {
    implBase_ = rhs.implBase_->clone();
    return *this;
  }

  Typeclass<[[+ fullBaseType +]]>& operator=
    (Typeclass<[[+ fullBaseType +]]>&& rhs)
  {
    implBase_ = rhs.implBase_->move_clone();
    return *this;
  }

[[~]] /**
[[~]] Generate functions. Example:
[[~]]   void has_enough_mana(
[[~]]     const char *spellname) const noexcept   {
[[~]]       implBase_->__has_enough_mana(spellname);
[[~]]   }
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods)
[[~]]    {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = isTypeclassMethod(method);
[[~]]      if(needPrint)
[[~]]      {
[[~]]         if(method->isTemplate())
[[~]]         {
template< [[+ expandTemplateNames(method->tplParams) +]] >
[[~]]         } // method->isTemplate
[[~]]         const std::string methodSpecificators
[[~]]            = printMethodForwarding(
[[~]]                method
[[~]]                , kSeparatorWhitespace
[[~]]               // what method printer is allowed to print
[[~]]                , MethodPrinter::Forwarding::Options::FORWARDING_ALL
[[~]]                  & ~MethodPrinter::Forwarding::Options::VIRTUAL);
[[+ methodSpecificators +]][[~]] /* no newline */
[[+ " " +]][[+ method->name +]][[~]] /* no newline */
[[~]]   // method has arguments
  (
[[+ expandMethodParameterDeclarations(method->params) +]][[~]] /* no newline */
  ) [[~]] /* no newline */
[[~]]        const std::string methodTrailing
[[~]]           = printMethodTrailing(
[[~]]               method
[[~]]               , kSeparatorWhitespace
[[~]]               // what method printer is allowed to print
[[~]]               , MethodPrinter::Trailing::Options::TRAILING_NOTHING
[[~]]                 | MethodPrinter::Trailing::Options::CONST
[[~]]                 | MethodPrinter::Trailing::Options::NOEXCEPT);
[[+ methodTrailing +]][[~]] /* no newline */
  {
[[~]] // call method from implementation
    implBase_->__[[+ method->name +]]
[[~]]   // method has arguments
      ([[+ expandMethodParameterNames(method->params) +]]);
  }
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

private:
  // This is actually a unique_ptr to an impl type.
  std::unique_ptr<
    TypeclassImplBase<[[+ fullBaseType +]]>
  > implBase_;
};

[[~]] if(!targetTypeName.empty()) {
// Type alias, alias template (since C++11)
using [[+ targetTypeName +]] = Typeclass<[[+ fullBaseType +]]>;

// fullBaseType may be VERY long templated type,
// but we can shorten it with #define
#define DEFINE_[[+ targetTypeName +]] [[+ fullBaseType +]]
[[~]] } // if(!targetTypeName.empty())

} // namespace poly
} // namespace generated

[[+ endHeaderGuard(headerGuard) /* no newline */ +]][[~]]
