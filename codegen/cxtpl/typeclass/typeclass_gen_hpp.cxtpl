[[~ // parameters begin

const size_t ReflectedStructInfoMethodsSize =
    ReflectedStructInfo->methods.size();

const size_t ReflectedStructInfoCompoundIdSize =
    ReflectedStructInfo->compoundId.size();

// parameters end
/* no newline */ ~]][[~]]
// This is generated file. Do not modify directly.
// Path to the code generator: [[+ generator_path +]].

[[+ startHeaderGuard(headerGuard) /* no newline */ +]][[~]]

[[~]] for(const auto& fileName: generator_includes) {
[[+ fileName +]]
[[~]] } // end for

#include <array>
#include <functional>
#include <memory>

namespace poly {
namespace generated {

[[~]] /**
[[~]] Getting rid of member functions.
[[~]] Decouples objects from their implementation.
[[~]] EXAMPLE:
[[~]]   template<
[[~]]     typename T0,
[[~]]     typename V,
[[~]]     typename std::enable_if<std::is_same<MagicItem, T0>::value>::type* = nullptr
[[~]]   >
[[~]]   void has_enough_mana(const V&, const char *spellname) noexcept ;
[[~]]
[[~]] USAGE EXAMPLE:
[[~]]   template<>
[[~]]   void has_enough_mana<DEFINE_MagicItem, FireSpell>
[[~]]       (const FireSpell& data, const char* spellname) noexcept {
[[~]]       std::cout << "(lib1) has_enough_mana " << " by "
[[~]]         << data.title << " " << spellname << std::endl;
[[~]]   }
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods) {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = !method->isImplicit
[[~]]          && !method->isOperator
[[~]]          && !method->isCtor
[[~]]          && !method->isDtor;
[[~]]      const std::string tplTypenames = typenameParamsFullDecls(method->params);
[[~]]      if(needPrint) {
  template<
    [[+ tplTypenames +]][[+ tplTypenames.empty() ? "" : "," +]]
[[~]]    int index_compoundId1 = 0;
[[~]]    for(const auto& compoundId: ReflectedStructInfo->compoundId) {
    typename T[[* index_compoundId1 *]],
[[~]]      index_compoundId1++;
[[~]]    } // end for
    typename V,
[[~]]    int index_compoundId2 = 0;
[[~]]    for(const auto& compoundId: ReflectedStructInfo->compoundId) {
[[~]]      const std::string delimiter =
[[~]]       index_compoundId2 < (ReflectedStructInfoCompoundIdSize - 1) ? "," : "";
    typename std::enable_if<std::is_same<[[+ compoundId +]], T[[* index_compoundId2 *]]>::value>::type* = nullptr[[+ delimiter +]]
[[~]]      index_compoundId2++;
[[~]]    } // end for
  >
[[+ method->isExplicitCtor ? "explicit " : "" +]][[~]] /* no newline */
[[+ method->isConstexpr ? "constexpr " : "" +]][[~]] /* no newline */
[[+ method->isStatic ? "static " : "" +]][[~]] /* no newline */
[[+ method->returnType->getPrintedName() +]][[~]] /* no newline */
[[+ " " +]][[~]] /* no newline */
[[+ method->name +]][[~]] /* no newline */
(const V&[[~]]/* no newline */
[[~]] if(methodParamsSize) {
[[+   ", " +]][[~]] /* no newline */
[[+ paramsFullDecls(method->params) +]][[~]] /* no newline */
[[~]] } // methodParamsSize
) [[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
;
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

// typeclass will store pointer to |implBase_|
// We use |implBase_| as base class for typeclass instance
[[~]] // where `fullBaseType` is trait like `Printable`
template<>
struct TypeclassImplBase<[[+ fullBaseType +]]> {
  TypeclassImplBase() = default;

  // We store a pointer to the base type
  // and rely on TypeclassImplBase's virtual dtor to free the object.
  virtual ~TypeclassImplBase() {}

  virtual
    std::unique_ptr<TypeclassImplBase>
      clone() = 0;

  virtual
    std::unique_ptr<TypeclassImplBase>
      move_clone() = 0;

[[~]] /**
[[~]] Generate functions. Example:
[[~]]   virtual void __has_enough_mana(
[[~]]     const char *spellname) const noexcept = 0 ;
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods) {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = !method->isImplicit
[[~]]          && !method->isOperator
[[~]]          && !method->isCtor
[[~]]          && !method->isDtor;
[[~]]      if(method->isTemplate()) {
template< [[+ expandTemplateParameters(method->tplParams) +]] >
[[~]]      } // method->isTemplate
[[~]]      if(needPrint) {
[[+ method->isExplicitCtor ? "explicit " : "" +]][[~]] /* no newline */
[[+ method->isVirtual ? "virtual " : "" +]][[~]] /* no newline */
[[+ method->isConstexpr ? "constexpr " : "" +]][[~]] /* no newline */
[[+ method->isStatic ? "static " : "" +]][[~]] /* no newline */
[[+ method->returnType->getPrintedName() +]][[~]] /* no newline */
[[+ " __" +]][[~]] /* no newline */
[[+ method->name +]][[~]] /* no newline */
(
[[+ paramsFullDecls(method->params) +]][[~]] /* no newline */
) [[~]] /* no newline */
[[+ method->isConst ? "const " : "" +]][[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
[[+ method->isPure ? "= 0 " : "" +]][[~]] /* no newline */
[[+ method->isDeleted ? "= delete " : "" +]][[~]] /* no newline */
[[+ method->isDefault ? "= default " : "" +]][[~]] /* no newline */
[[~]]      if(method->isDefined && method->isClassScopeInlined) {
[[+ method->body +]]
[[~]]      } else {
;
[[~]]      } // method->isDefined && method->isClassScopeInlined
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

};

[[~]] // where `fullBaseType` is trait like `Printable`
template<>
struct Typeclass<[[+ fullBaseType +]]> {
  Typeclass()
    : implBase_{}
  {}

  Typeclass(
    const Typeclass<[[+ fullBaseType +]]>& rhs)
    : implBase_(rhs.implBase_->clone())
  {}

  Typeclass(Typeclass<[[+ fullBaseType +]]>&& rhs)
  {
    implBase_ = rhs.implBase_->move_clone();
  }

[[~]] // where ImplType is impl that can behave as `fullBaseType`
  template<
    typename ImplType
    /// \note use TypeclassRef<ImplType> for references
    //, typename = IsNotReference<ImplType>
    /// \note can't pass Typeclass here
    , typename std::enable_if<
        !std::is_same<Typeclass, std::decay_t<ImplType>>::value
      >::type* = nullptr
  >
  Typeclass(ImplType&& impl)
    : implBase_(
        std::make_unique<
          TypeclassImpl<
            std::decay_t<ImplType>
            , [[+ fullBaseType +]]
          >
        >
        (std::forward<ImplType>(impl)))
  {}

  Typeclass<[[+ fullBaseType +]]>& operator=
    (const Typeclass<[[+ fullBaseType +]]>& rhs)
  {
    implBase_ = rhs.implBase_->clone();
    return *this;
  }

  Typeclass<[[+ fullBaseType +]]>& operator=
    (Typeclass<[[+ fullBaseType +]]>&& rhs)
  {
    implBase_ = rhs.implBase_->move_clone();
    return *this;
  }

[[~]] // where ImplType is impl that can behave as `fullBaseType`
  //template<
  //  typename ImplType
  //  //, typename = IsNotReference<ImplType>
  //  , typename std::enable_if<
  //      !std::is_same<Typeclass, std::decay_t<ImplType>>::value
  //    >::type* = nullptr
  //>
  //Typeclass<[[+ fullBaseType +]]>& operator=(
  //  ImplType&& impl)
  //{
  //  implBase_.reset(
  //    new TypeclassImpl<std::decay_t<ImplType>>(
  //      std::forward<ImplType>(impl)));
  //  return *this;
  //}

[[~]] // where ImplType is impl that can behave as `fullBaseType`
  /**
   * Allows to write code like:
    FireSpell spell {"title5", "description5"};
    Spell myspell = spell;
   **/
  //template<
  //  typename ImplType
  //  //, typename = IsNotReference<ImplType>
  //  , typename std::enable_if<
  //      !std::is_same<Typeclass, std::decay_t<ImplType>>::value
  //    >::type* = nullptr
  //>
  //Typeclass<[[+ fullBaseType +]]>& operator=(
  //  const ImplType& impl)
  //{
  //  implBase_.reset(
  //    new TypeclassImpl<std::decay_t<ImplType>>(
  //      std::forward<ImplType>(impl)));
  //  return *this;
  //}

[[~]] /**
[[~]] Generate functions. Example:
[[~]]   void has_enough_mana(
[[~]]     const char *spellname) const noexcept   {
[[~]]       implBase_->__has_enough_mana(spellname);
[[~]]   }
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedStructInfo->methods)
[[~]]    {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = !method->isImplicit
[[~]]          && !method->isOperator
[[~]]          && !method->isCtor
[[~]]          && !method->isDtor;
[[~]]      if(method->isTemplate())
[[~]]      {
template< [[+ expandTemplateParameters(method->tplParams) +]] >
[[~]]      } // method->isTemplate
[[~]]      if(needPrint)
[[~]]      {
[[+ method->isExplicitCtor ? "explicit " : "" +]][[~]] /* no newline */
[[+ method->isConstexpr ? "constexpr " : "" +]][[~]] /* no newline */
[[+ method->isStatic ? "static " : "" +]][[~]] /* no newline */
[[+ method->returnType->getPrintedName() +]][[~]] /* no newline */
[[+ " " +]][[~]] /* no newline */
[[+ method->name +]][[~]] /* no newline */
(
[[+ paramsFullDecls(method->params) +]][[~]] /* no newline */
) [[~]] /* no newline */
[[+ method->isConst ? "const " : "" +]][[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
  {
    implBase_->__[[+ method->name +]]([[+ expandMethodParameters(method->params) +]]);
  }
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

private:
  // This is actually a unique_ptr to an impl type.
  std::unique_ptr<
    TypeclassImplBase<[[+ fullBaseType +]]>
  > implBase_;
};

[[~]] if(!targetTypeName.empty()) {
// Type alias, alias template (since C++11)
using [[+ targetTypeName +]] = Typeclass<[[+ fullBaseType +]]>;

// fullBaseType may be VERY long templated type,
// but we can shorten it with #define
#define DEFINE_[[+ targetTypeName +]] [[+ fullBaseType +]]
[[~]] } // if(!targetTypeName.empty())

} // namespace poly
} // namespace generated

[[+ endHeaderGuard(headerGuard) /* no newline */ +]][[~]]
