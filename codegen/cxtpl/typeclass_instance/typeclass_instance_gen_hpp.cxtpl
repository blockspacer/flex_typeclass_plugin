[[~ // parameters begin

// parameters end
/* no newline */ ~]][[~]]
// This is generated file. Do not modify directly.
// Path to the code generator: [[+ generator_path +]].

[[+ startHeaderGuard(headerGuard) /* no newline */ +]][[~]]

[[~]] for(const auto& fileName: generator_includes) {
[[+ fileName +]]
[[~]] } // end for

#include <array>
#include <functional>
#include <memory>

namespace poly {
namespace generated {

[[~]] /**
[[~]] EXAMPLE:
[[~]]   template<>
[[~]]   void print< Printable, WaterSpell >
[[~]]     (const WaterSpell& data) noexcept ;
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedBaseTypeclass->methods) {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = !method->isImplicit
[[~]]          && !method->isOperator
[[~]]          && !method->isCtor
[[~]]          && !method->isDtor;
[[~]]      if(needPrint) {
  template<>
[[+ method->isExplicitCtor ? "explicit " : "" +]][[~]] /* no newline */
[[+ method->isConstexpr ? "constexpr " : "" +]][[~]] /* no newline */
[[+ method->isStatic ? "static " : "" +]][[~]] /* no newline */
[[+ method->returnType->getPrintedName() +]][[~]] /* no newline */
[[+ " " +]][[~]] /* no newline */
[[+ method->name +]][[~]] /* no newline */
< [[+ BaseTypeclassName +]], [[+ ImplTypeclassName +]] >
(const [[+ ImplTypeclassName +]]& data[[~]] /* no newline */
[[~]] if(methodParamsSize) {
[[+   ", " +]][[~]] /* no newline */
[[+ paramsFullDecls(method->params) +]][[~]] /* no newline */
[[~]] } // methodParamsSize
) [[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
;
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

[[~]] // where `BaseTypeclassName` is trait like `Printable`
template<>
struct
  TypeclassImpl<
    [[+ ImplTypeclassName +]],
    [[+ BaseTypeclassName +]]
  >
  : public TypeclassImplBase<[[+ BaseTypeclassName +]]>
{
  typedef [[+ ImplTypeclassName +]] type;

  TypeclassImpl(
    const [[+ ImplTypeclassName +]]& arg)
    : concreteData_(arg)
  {}

  TypeclassImpl(
    [[+ ImplTypeclassName +]]&& arg)
    : concreteData_(std::move(arg))
  {}

  // Construct the embedded concrete type from multiple arguments.
  template<typename... args_t>
  TypeclassImpl(args_t&&... args)
    : concreteData_(std::forward<args_t>(args)...)
  {}

  // Construct the embedded concrete type from multiple arguments.
  template<typename... args_t>
  TypeclassImpl(const args_t&... args)
    : concreteData_(std::forward<args_t>(args)...)
  {}

[[~]] /**
[[~]] EXAMPLE:
[[~]] void __print() const noexcept override final
[[~]] {
[[~]]   return print< Printable >(concrete);
[[~]] }
[[~]] **/
[[~]]  { // startscope
[[~]]    for(const auto& method: ReflectedBaseTypeclass->methods) {
[[~]]      const size_t methodParamsSize = method->params.size();
[[~]]      const bool needPrint = !method->isImplicit
[[~]]          && !method->isOperator
[[~]]          && !method->isCtor
[[~]]          && !method->isDtor;
[[~]]      if(method->isTemplate()) {
template< [[+ expandTemplateParameters(method->tplParams) +]] >
[[~]]      } // method->isTemplate
[[~]]      if(needPrint) {
[[+ method->isExplicitCtor ? "explicit " : "" +]][[~]] /* no newline */
[[+ method->isConstexpr ? "constexpr " : "" +]][[~]] /* no newline */
[[+ method->isStatic ? "static " : "" +]][[~]] /* no newline */
[[+ method->returnType->getPrintedName() +]][[~]] /* no newline */
[[+ " __" +]][[~]] /* no newline */
[[+ method->name +]][[~]] /* no newline */
(
[[+ paramsFullDecls(method->params) +]][[~]] /* no newline */
) [[~]] /* no newline */
[[+ method->isConst ? "const " : "" +]][[~]] /* no newline */
[[+ method->isNoExcept ? "noexcept " : "" +]][[~]] /* no newline */
override final
  {
[[~]] /// \note passes data, not ref
    return [[+ method->name +]][[~]] /* no newline */
< [[+ BaseTypeclassName +]] >[[~]] /* no newline */
([[~]] /* no newline */
concreteData_[[~]] /* no newline */
[[+ methodParamsSize ? ", " : "" +]][[~]] /* no newline */
[[+ expandMethodParameters(method->params) +]][[~]] /* no newline */
);
  }
[[~ /* newline */ ~]]
[[~]]      } // needPrint
[[~]]    } // methods endfor
[[~]]  } // endscope

  std::unique_ptr<
      TypeclassImplBase<[[+ BaseTypeclassName +]]>>
  clone() override final
  {
      // Copy-construct a new instance of TypeclassImpl on the heap.
      return std::make_unique<TypeclassImpl<
        [[+ ImplTypeclassName +]],
        [[+ BaseTypeclassName +]]
      >>(concreteData_);
  }

  std::unique_ptr<
      TypeclassImplBase<[[+ BaseTypeclassName +]]>>
  move_clone() override final
  {
      // Copy-construct a new instance of TypeclassImpl on the heap.
      return std::make_unique<TypeclassImpl<
        [[+ ImplTypeclassName +]],
        [[+ BaseTypeclassName +]]
      >>(std::move(concreteData_));
  }

  // Our actual data
  // that can implement `BaseTypeclassName`
  // (where `BaseTypeclassName` is trait like `Printable`)
  [[+ ImplTypeclassName +]] concreteData_;
};

} // namespace poly
} // namespace generated

[[+ endHeaderGuard(headerGuard) /* no newline */ +]][[~]]
